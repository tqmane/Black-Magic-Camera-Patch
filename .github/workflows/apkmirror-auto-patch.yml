name: APKMirror Auto Patch

on:
  schedule:
    - cron: '17 3 * * *'
  workflow_dispatch:
    inputs:
      force:
        description: 'Force run even if no new release detected'
        required: false
        type: boolean
        default: false
      app_url:
        description: 'Override APKMirror app URL'
        required: false
        type: string
      fallback_apk:
        description: 'Path to local APK to use if download fails (optional)'
        required: false
        type: string
      fallback_apk_url:
        description: 'Direct URL to .apk/.apkm to use if APKMirror download fails (optional)'
        required: false
        type: string

permissions:
  contents: write

concurrency:
  group: apkmirror-auto-patch
  cancel-in-progress: false

jobs:
  auto-patch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements.txt

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3
        with:
          packages: >-
            build-tools;34.0.0
            platforms;android-34
            platform-tools

      - name: Check APKMirror for latest Blackmagic Camera
        id: check
        run: |
          APP_URL_ARG=""
          if [ -n "${{ inputs.app_url }}" ]; then APP_URL_ARG="--app-url '${{ inputs.app_url }}'"; fi
          FALLBACK_ARG=""
          if [ -n "${{ inputs.fallback_apk }}" ]; then FALLBACK_ARG="--fallback-apk '${{ inputs.fallback_apk }}'"; elif [ -f "Blackmagic Camera_v3.0.2.0016(78)_antisplit.apk" ]; then FALLBACK_ARG="--fallback-apk 'Blackmagic Camera_v3.0.2.0016(78)_antisplit.apk'"; fi
          FORCE_ARG=""
          if [ "${{ inputs.force }}" = "true" ]; then FORCE_ARG="--force --skip-release-check"; fi
          python scripts/check_apkmirror.py $APP_URL_ARG $FALLBACK_ARG $FORCE_ARG --out build/latest.json
          has_update=$(jq -r '.has_update' build/latest.json || echo false)
          echo "has_update=$has_update" >> $GITHUB_OUTPUT
          version=$(jq -r '.version // ""' build/latest.json)
          echo "version=$version" >> $GITHUB_OUTPUT
          apk_path=$(jq -r '.apk_path // ""' build/latest.json)
          echo "apk_path=$apk_path" >> $GITHUB_OUTPUT
          download_url=$(jq -r '.download_url // ""' build/latest.json)
          echo "download_url=$download_url" >> $GITHUB_OUTPUT
          download_page=$(jq -r '.download_page // ""' build/latest.json)
          echo "download_page=$download_page" >> $GITHUB_OUTPUT
          package_type=$(jq -r '.package_type // "unknown"' build/latest.json)
          echo "package_type=$package_type" >> $GITHUB_OUTPUT
          note=$(jq -r '.note // ""' build/latest.json)
          echo "note=$note" >> $GITHUB_OUTPUT

      - name: Try download via apkmirror-downloader
        id: apkmd
        if: steps.check.outputs.apk_path == ''
        run: |
          mkdir -p build
          echo "Attempting download via apkmirror-downloader (APK)..."
          npm i --no-save apkmirror-downloader@latest || true
          cat > scripts/apkmd_fetch.mjs <<'EOF'
          import { APKMirrorDownloader } from 'apkmirror-downloader';
          import fs from 'node:fs';
          import path from 'node:path';
          const outDir = 'build';
          const type = process.env.TYPE || 'apk';
          const org = process.env.ORG || 'blackmagic-design';
          const repo = process.env.REPO || 'blackmagic-camera';
          const outFile = type === 'apk' ? 'from_apkmd.apk' : 'from_apkmd.apkm';
          const downloader = new APKMirrorDownloader({ outDir, overwrite: true, arch: 'universal', dpi: 'nodpi' });
          try {
            await downloader.download({ org, repo }, { type, outFile });
            const p = path.resolve(outDir, outFile);
            if (fs.existsSync(p) && fs.statSync(p).size > 1024*1024) {
              console.log('OK ' + p);
              process.exit(0);
            }
          } catch (e) {
            console.error('ERR', e?.message || e);
          }
          process.exit(2);
          EOF
          node scripts/apkmd_fetch.mjs || true
          if [ -f build/from_apkmd.apk ]; then echo "apk_path=$(pwd)/build/from_apkmd.apk" >> $GITHUB_OUTPUT; fi
          if [ ! -f build/from_apkmd.apk ]; then
            echo "Attempting download via apkmirror-downloader (Bundle)..."
            TYPE=bundle node scripts/apkmd_fetch.mjs || true
          fi
          if [ -f build/from_apkmd.apkm ]; then
            echo "Extracting from .apkm (apkmd) ..."
            python scripts/extract_from_apkm.py --apkm build/from_apkmd.apkm --out build/from_apkmd_extracted.apk || true
          fi
          if [ -f build/from_apkmd_extracted.apk ]; then echo "apk_path=$(pwd)/build/from_apkmd_extracted.apk" >> $GITHUB_OUTPUT; fi

      - name: Try download APK from checker URL
        id: try_dl
        if: (steps.check.outputs.apk_path == '' || endsWith(steps.check.outputs.apk_path, '.apkm')) && steps.check.outputs.download_url != ''
        run: |
          mkdir -p build
          echo "Attempting to download APK from checker-provided URL..."
          EXT="apk"
          case "${{ steps.check.outputs.package_type }}" in
            apkm) EXT="apkm" ;;
            xapk) EXT="xapk" ;;
          esac
          REF="${{ steps.check.outputs.download_page }}"
          if [ -z "$REF" ]; then REF="https://www.apkmirror.com/"; fi
          curl -L --fail -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36" -H "Referer: $REF" -o build/from_checker.$EXT "${{ steps.check.outputs.download_url }}" || true
          if [ -f build/from_checker.apkm ]; then
            echo "Extracting from .apkm ..."
            python scripts/extract_from_apkm.py --apkm build/from_checker.apkm --out build/from_checker.apk || true
          fi
          if [ -f build/from_checker.xapk ]; then
            echo "Extracting from .xapk ..."
            python scripts/extract_from_apkm.py --apkm build/from_checker.xapk --out build/from_checker.apk || true
          fi
          # Validate APK; if invalid ZIP, try extracting as APKM
          if [ -f build/from_checker.apk ]; then
            if ! unzip -t build/from_checker.apk >/dev/null 2>&1; then
              echo "from_checker.apk is not a valid ZIP, attempting APKM extraction..."
              cp -f build/from_checker.apk build/from_checker.apkm || true
              python scripts/extract_from_apkm.py --apkm build/from_checker.apkm --out build/from_checker_extracted.apk || true
              if [ -f build/from_checker_extracted.apk ]; then mv -f build/from_checker_extracted.apk build/from_checker.apk; fi
            fi
          fi
          if [ -f build/from_checker.apk ] && unzip -t build/from_checker.apk >/dev/null 2>&1; then echo "apk_path=$(pwd)/build/from_checker.apk" >> $GITHUB_OUTPUT; fi

      - name: Try download APK from FALLBACK_APK_URL variable
        id: try_fallback_url
        if: steps.apkmd.outputs.apk_path == '' && steps.try_dl.outputs.apk_path == ''
        run: |
          mkdir -p build
          echo "Attempting to download APK from FALLBACK_APK_URL..."
          URL="${{ inputs.fallback_apk_url }}"
          if [ -z "$URL" ]; then URL="${{ vars.FALLBACK_APK_URL }}"; fi
          if [ -z "$URL" ]; then echo "No fallback URL provided. Skipping this attempt."; exit 0; fi
          EXT="apk"
          if [[ "$URL" == *.apkm ]]; then EXT="apkm"; fi
          curl -L --fail -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36" -H "Referer: https://www.apkmirror.com/" -o build/from_fallback_url.$EXT "$URL" || true
          if [ -f build/from_fallback_url.apkm ]; then
            echo "Extracting from .apkm ..."
            python scripts/extract_from_apkm.py --apkm build/from_fallback_url.apkm --out build/from_fallback_url.apk || true
          fi
          if [ -f build/from_fallback_url.xapk ]; then
            echo "Extracting from .xapk ..."
            python scripts/extract_from_apkm.py --apkm build/from_fallback_url.xapk --out build/from_fallback_url.apk || true
          fi
          # Validate APK; if invalid ZIP, try extracting as APKM
          if [ -f build/from_fallback_url.apk ]; then
            if ! unzip -t build/from_fallback_url.apk >/dev/null 2>&1; then
              echo "from_fallback_url.apk is not a valid ZIP, attempting APKM extraction..."
              cp -f build/from_fallback_url.apk build/from_fallback_url.apkm || true
              python scripts/extract_from_apkm.py --apkm build/from_fallback_url.apkm --out build/from_fallback_url_extracted.apk || true
              if [ -f build/from_fallback_url_extracted.apk ]; then mv -f build/from_fallback_url_extracted.apk build/from_fallback_url.apk; fi
            fi
          fi
          if [ -f build/from_fallback_url.apk ] && unzip -t build/from_fallback_url.apk >/dev/null 2>&1; then echo "apk_path=$(pwd)/build/from_fallback_url.apk" >> $GITHUB_OUTPUT; fi

      - name: Resolve APK path
        id: resolve_apk
        run: |
          final_apk="${{ steps.apkmd.outputs.apk_path }}"
          if [ -z "$final_apk" ]; then
            final_apk="${{ steps.try_fallback_url.outputs.apk_path }}"
          fi
          if [ -z "$final_apk" ]; then
            final_apk="${{ steps.try_dl.outputs.apk_path }}"
          fi
          if [ -z "$final_apk" ]; then
            final_apk="${{ steps.check.outputs.apk_path }}"
          fi
          if [ -z "$final_apk" ]; then
            if [ -n "${{ inputs.fallback_apk }}" ] && [ -f "${{ inputs.fallback_apk }}" ]; then
              final_apk="${{ inputs.fallback_apk }}"
            elif [ -f "Blackmagic Camera_v3.0.2.0016(78)_antisplit.apk" ]; then
              final_apk="Blackmagic Camera_v3.0.2.0016(78)_antisplit.apk"
            fi
          fi
          echo "Listing APKs in workspace (for debugging):"
          find . -type f -name "*.apk" -printf "%s %p\n" 2>/dev/null | sort -nr | head -50 || true
          echo "Listing APKM in workspace (for debugging):"
          find . -type f -name "*.apkm" -printf "%s %p\n" 2>/dev/null | sort -nr | head -50 || true
          if [ -z "$final_apk" ]; then
            apkm_cand=$(find . -type f -name "*.apkm" -printf "%s %p\n" 2>/dev/null | sort -nr | awk 'NR==1{print $2}')
            if [ -n "$apkm_cand" ] && [ -f "$apkm_cand" ]; then
              echo "Extracting APK from $apkm_cand ..."
              mkdir -p build
              python scripts/extract_from_apkm.py --apkm "$apkm_cand" --out build/apkm_extracted.apk || true
              if [ -f build/apkm_extracted.apk ]; then final_apk="$(pwd)/build/apkm_extracted.apk"; fi
            fi
          fi
          echo "Listing XAPK in workspace (for debugging):"
          find . -type f -name "*.xapk" -printf "%s %p\n" 2>/dev/null | sort -nr | head -50 || true
          if [ -z "$final_apk" ]; then
            xapk_cand=$(find . -type f -name "*.xapk" -printf "%s %p\n" 2>/dev/null | sort -nr | awk 'NR==1{print $2}')
            if [ -n "$xapk_cand" ] && [ -f "$xapk_cand" ]; then
              echo "Extracting APK from $xapk_cand ..."
              mkdir -p build
              python scripts/extract_from_apkm.py --apkm "$xapk_cand" --out build/xapk_extracted.apk || true
              if [ -f build/xapk_extracted.apk ]; then final_apk="$(pwd)/build/xapk_extracted.apk"; fi
            fi
          fi
          if [ -z "$final_apk" ]; then
            # last-resort: pick largest APK found in repo (recursive)
            cand=$(find . -type f -name "*.apk" -printf "%s %p\n" 2>/dev/null | sort -nr | awk 'NR==1{print $2}')
            if [ -n "$cand" ] && [ -f "$cand" ]; then final_apk="$cand"; fi
          fi
          if [ -z "$final_apk" ] || [ ! -f "$final_apk" ]; then
            echo "final_apk=" >> $GITHUB_OUTPUT
          else
            echo "final_apk=$final_apk" >> $GITHUB_OUTPUT
          fi

      - name: Ensure apktool.jar
        run: |
          if [ ! -f apktool.jar ]; then
            echo "Downloading apktool.jar ..."
            curl -L -o apktool.jar https://github.com/iBotPeaches/Apktool/releases/download/v2.9.3/apktool_2.9.3.jar
          fi

      - name: Stop if no update
        if: steps.check.outputs.has_update != 'true' && inputs.force != true
        run: |
          if [ "${{ steps.check.outputs.package_type }}" = "apkm" ] || [ "${{ steps.check.outputs.package_type }}" = "xapk" ]; then
            echo "No APK available (.${{ steps.check.outputs.package_type }} detected). Provide fallback_apk or FALLBACK_APK_URL." >&2
          else
            echo "No update found. Exiting."
          fi

      - name: Detect keystore presence
        if: steps.check.outputs.has_update == 'true'
        run: |
          if [ -n "${{ secrets.BLACKMAGIC_KEYSTORE_B64 }}" ] && [ -n "${{ secrets.BLACKMAGIC_KEY_ALIAS }}" ] && [ -n "${{ secrets.BLACKMAGIC_KEYSTORE_PASSWORD }}" ] && [ -n "${{ secrets.BLACKMAGIC_KEY_PASSWORD }}" ]; then
            echo "HAS_KEYSTORE=true" >> $GITHUB_ENV
          else
            echo "HAS_KEYSTORE=false" >> $GITHUB_ENV
          fi

      - name: Prepare keystore (if provided)
        if: steps.check.outputs.has_update == 'true' && env.HAS_KEYSTORE == 'true'
        env:
          KEYSTORE_B64: ${{ secrets.BLACKMAGIC_KEYSTORE_B64 }}
        run: |
          mkdir -p build
          echo "$KEYSTORE_B64" | base64 -d > build/blackmagic.keystore
        shell: bash

      - name: Decode, apply patch, and build
        if: (steps.check.outputs.has_update == 'true' || inputs.force == true) && steps.resolve_apk.outputs.final_apk != ''
        id: build
        env:
          ZIPALIGN: ${{ env.ANDROID_SDK_ROOT }}/build-tools/34.0.0/zipalign
          APKSIGNER: ${{ env.ANDROID_SDK_ROOT }}/build-tools/34.0.0/apksigner
          KEY_ALIAS: ${{ secrets.BLACKMAGIC_KEY_ALIAS }}
          KEYSTORE_PASSWORD: ${{ secrets.BLACKMAGIC_KEYSTORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.BLACKMAGIC_KEY_PASSWORD }}
        run: |
          python scripts/decode_and_apply_patch.py \
            --apk "${{ steps.resolve_apk.outputs.final_apk }}" \
            --apktool ./apktool.jar \
            --workdir build/work

          python scripts/build_and_sign.py \
            --decoded build/work/decoded_apk \
            --dist dist \
            --zipalign "$ZIPALIGN" \
            --apksigner "$APKSIGNER" \
            --keystore build/blackmagic.keystore \
            --key-alias "$KEY_ALIAS" \
            --keystore-pass "$KEYSTORE_PASSWORD" \
            --key-pass "$KEY_PASSWORD" \
            --version "${{ steps.check.outputs.version }}" \
            --maybe-unsigned $([ "$HAS_KEYSTORE" = "true" ] || echo "--unsigned-only")

      - name: Fail if APK is unresolved
        if: (steps.check.outputs.has_update == 'true' || inputs.force == true) && steps.resolve_apk.outputs.final_apk == ''
        run: |
          echo "ERROR: APK path could not be resolved." >&2
          echo "Hints:" >&2
          echo " - Provide an existing file via workflow input 'fallback_apk' (absolute or relative path)." >&2
          echo " - Or provide a direct URL via input 'fallback_apk_url' or set repo variable FALLBACK_APK_URL." >&2
          echo " - You can also re-run with 'force=false' to skip failure when APKMirror doesn't expose a direct download." >&2
          exit 1

      - name: Upload artifacts
        if: steps.check.outputs.has_update == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: blackmagic-mod-${{ steps.check.outputs.version }}
          path: |
            dist/*.apk
            build/work/*.txt

      - name: Create GitHub release
        if: steps.check.outputs.has_update == 'true' && env.HAS_KEYSTORE == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: blackmagic-${{ steps.check.outputs.version }}
          name: Blackmagic Camera Mod ${{ steps.check.outputs.version }}
          body: |
            Automated build from APKMirror.
            Version: ${{ steps.check.outputs.version }}
          files: |
            dist/*_signed.apk


